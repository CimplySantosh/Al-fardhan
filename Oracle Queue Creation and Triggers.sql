-- Pre Process for Setup One time setup

-- Following is run by SYS as SYSDBA

CREATE USER SYNCUSER identified by Systech123;
GRANT CREATE SESSION TO SYNCUSER;
-- For basic table operations
GRANT CREATE TABLE TO SYNCUSER;
GRANT CREATE SEQUENCE TO SYNCUSER;
-- Grant necessary privileges
-- For working with queues
GRANT CREATE PROCEDURE TO SYNCUSER;

GRANT CONNECT, RESOURCE TO SYNCUSER;
GRANT EXECUTE ON DBMS_AQ TO SYNCUSER;
GRANT EXECUTE ON DBMS_AQADM TO SYNCUSER;
GRANT EXECUTE ON DBMS_AQIN TO SYNCUSER; -- Check if this 11g
GRANT EXECUTE ON DBMS_AQJMS TO SYNCUSER; -- Check if this 11g
ALTER USER SYNCUSER QUOTA 200M ON USERS;
GRANT SELECT ON V$AQ TO SYNCUSER;


-- GRANT SELECT, INSERT, UPDATE, DELETE ON some_table TO SYNCUSER;



--- Connect as SYNCUSER and do the following

--- Create Queue
BEGIN
  DBMS_AQADM.CREATE_QUEUE_TABLE(
    queue_table        => 'CDC_ROW_AUDIT_1_EVENT_QUEUE_TABLE',
    queue_payload_type => 'SYS.AQ$_JMS_TEXT_MESSAGE'
    sort_list          => 'ENQ_TIME',
    multiple_consumers => FALSE,
    message_grouping   => DBMS_AQADM.NONE,
    comment            => 'Queue table for a set of CDC Tables'
  );

  DBMS_AQADM.CREATE_QUEUE(
    queue_name         => 'CDC_ROW_AUDIT_1_EVENT_QUEUE',
    queue_table        => 'CDC_ROW_AUDIT_1_EVENT_QUEUE_TABLE',
    queue_type   => DBMS_AQADM.NORMAL_QUEUE,
    max_retries  => 15,
    retry_delay  => 60,
    retention_time => 172800, -- 48 hours
    comment      => 'Queue for customer master messages'
  );

  DBMS_AQADM.CREATE_QUEUE(
    queue_name         => 'CDC_ROW_AUDIT_1_EVENT_QUEUE',
    queue_table        => 'CDC_ROW_AUDIT_1_EVENT_QUEUE_TABLE',
    queue_type   => DBMS_AQADM.NORMAL_QUEUE,
    max_retries  => 15,
    retry_delay  => 60,
    retention_time => 172800, -- 48 hours
    comment      => 'Queue for customer detail messages'
  );


  DBMS_AQADM.START_QUEUE(
	queue_name => 'CDC_ROW_AUDIT_1_EVENT_QUEUE',
    enqueue    => TRUE,
    dequeue    => TRUE
  );

END;
/

/*

-- Stop queue temporarily for maintenance
BEGIN
  DBMS_AQADM.STOP_QUEUE(
    queue_name => 'CDC_CUSTOMER_MASTER_AQ',
    enqueue    => TRUE,  -- Stop new messages
    dequeue    => TRUE, -- Stop processing messages
    wait       => TRUE
  );
END;
/

-- Drop queue (must be stopped first)
BEGIN
  DBMS_AQADM.DROP_QUEUE(
    queue_name => 'CDC_CUSTOMER_MASTER_AQ',
    auto_commit => TRUE
  );
END;
/


-- Drop queue table (must drop all queues first)

BEGIN
  DBMS_AQADM.DROP_QUEUE_TABLE(
    queue_table => 'CDC_ROW_AUDIT_1_EVENT_QUEUE_TABLE',
    force       => FALSE
  );
END;
/


PURGE_QUEUE_TABLE
-- Purge processed messages older than 7 days -- Good practice to do this.

BEGIN
  DBMS_AQADM.PURGE_QUEUE_TABLE(
    queue_table     => 'ORDER_QUEUE_TABLE',
    purge_condition => 'DEQ_TIME < SYSDATE - 7',
    purge_options   => DBMS_AQADM.PO_IGNORE_TRANSACTION
  );
END;
/

-- Modify queue properties

BEGIN
  DBMS_AQADM.ALTER_QUEUE(
    queue_name     => 'CDC_ROW_AUDIT_1_EVENT_QUEUE',
    max_retries    => 10,
    retry_delay    => 60,
    retention_time => 172800 -- 48 hours
  );
END;
/




Queue Information Queries
sql-- View queue information
SELECT *
FROM USER_QUEUES;

-- View queue table information
SELECT *
FROM USER_QUEUE_TABLES;

-- Check queue statistics
SELECT *
FROM V$AQ;


*/

CREATE SEQUENCE AUDITID_SEQ START WITH 1 INCREMENT BY 1;


--CDC Error file if there is failure in Queueing the meassage

CREATE TABLE CDC_ROW_AUDIT_1_AQ_ERROR_LOG (
    AuditID NUMBER PRIMARY KEY, -- GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, is not supported in 11g
	error_time  TIMESTAMP DEFAULT SYSTIMESTAMP,  --  Not sure if this is there in 11g -- Need to check if this needs to be changed to CURRENT_TIMESTAMP
	error_msg    VARCHAR2(4000),
	CDC_AUDIT_MESSAGE_DATA	CLOB,
    TableName VARCHAR2(100) NOT NULL,
    OperationType VARCHAR2(1) NOT NULL, -- 'I' for Insert, 'U' for Update, 'D' for Delete
	OperationKey VARCHAR2(32) NOT NULL, -- Key based on table & Combining PKs 
	OperationTimeKey VARCHAR2(32) NOT NULL, -- Key based on table & Combining PKs & Datetime2
    PK1 VARCHAR2(128) NOT NULL,          -- 1st Primary key of the affected record
    PK2 VARCHAR2(128),          -- 2nd Primary key of the affected record
    PK3 VARCHAR2(128),          -- 3rd Primary key of the affected record
    PK4 VARCHAR2(128),          -- 4th Primary key of the affected record
    PK5 VARCHAR2(128),          -- 5th Primary key of the affected record
    PK6 VARCHAR2(128),          -- 6th Primary key of the affected record
    PK7 VARCHAR2(128),          -- 7th Primary key of the affected record
    PK8 VARCHAR2(128),          -- 8th Primary key of the affected record
    PK9 VARCHAR2(128),          -- 9th Primary key of the affected record
    BeforeImage CLOB, -- Complete row JSON data before change (for updates and deletes)
    AfterImage CLOB,  -- Complete row JSON data after change (for inserts and updates)
    valid_data VARCHAR2(1) DEFAULT 'Y',
	processed_data VARCHAR2(1) DEFAULT 'N',
	applied_data VARCHAR2(1) DEFAULT 'N', 
    ChangeDate TIMESTAMP(6) DEFAULT SYSTIMESTAMP, -- CURRENT TIMESTAMP,
    ChangedBy VARCHAR2(100) DEFAULT USER --  check if this is supported in 11g else use CURRENT_USER
);

-------------


CREATE OR REPLACE PACKAGE CDC_UTILS AS
    
    -- Function to escape special characters for delimited format
    FUNCTION escape_string(p_string IN VARCHAR2) RETURN VARCHAR2;
    
    -- Function to create CDC message in pipe-delimited format
    FUNCTION create_cdc_message(
				p_queue_name IN VARCHAR2,
				p_table_name IN VARCHAR2,
				p_operation IN VARCHAR2,
				p_operation_key IN VARCHAR2,
				p_operation_time_key IN VARCHAR2,
				p_pk1 IN VARCHAR2,
				p_pk2 IN VARCHAR2,
				p_pk3 IN VARCHAR2,
				p_pk4 IN VARCHAR2,
				p_pk5 IN VARCHAR2,
				p_pk6 IN VARCHAR2,
				p_pk7 IN VARCHAR2,
				p_pk8 IN VARCHAR2,
				p_pk9 IN VARCHAR2,
				p_old_values IN VARCHAR2,
				p_new_values IN VARCHAR2,
				p_valid_data IN VARCHAR2,
				p_processed_data IN VARCHAR2,
				p_applied_data IN VARCHAR2,
				p_changed_date IN TIMESTAMP,
				p_changed_user IN VARCHAR2 
    ) RETURN VARCHAR2;
	
END CDC_UTILS;
/

CREATE OR REPLACE PACKAGE BODY CDC_UTILS AS
       
    FUNCTION escape_string(p_string IN VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        -- Replace pipe characters and handle nulls
        RETURN REPLACE(REPLACE(NVL(p_string, 'NULL'), '|', '\|'), CHR(10), '\n');
    END escape_string;
    
    FUNCTION create_cdc_message(
		p_queue_name IN VARCHAR2,
        p_table_name IN VARCHAR2,
        p_operation IN VARCHAR2,
		p_operation_key IN VARCHAR2,
		p_operation_time_key IN VARCHAR2,
		p_pk1 IN VARCHAR2,
		p_pk2 IN VARCHAR2,
		p_pk3 IN VARCHAR2,
		p_pk4 IN VARCHAR2,
		p_pk5 IN VARCHAR2,
		p_pk6 IN VARCHAR2,
		p_pk7 IN VARCHAR2,
		p_pk8 IN VARCHAR2,
		p_pk9 IN VARCHAR2,
        p_old_values IN VARCHAR2,
        p_new_values IN VARCHAR2,
		p_valid_data IN VARCHAR2,
		p_processed_data IN VARCHAR2,
		p_applied_data IN VARCHAR2,
        p_changed_date IN TIMESTAMP,
		p_changed_user IN VARCHAR2
    ) RETURN VARCHAR2 IS 
    
	enqueue_options    DBMS_AQ.ENQUEUE_OPTIONS_T;
	message_properties DBMS_AQ.MESSAGE_PROPERTIES_T;
	message_handle     RAW(16);
	message            SYS.AQ$_JMS_TEXT_MESSAGE;
    l_errormsg VARCHAR2(4000);
    l_success_flg VARCHAR2(1);
	l_message clob :='';

    BEGIN
        -- Create pipe-delimited message format
        -- Format: TABLE|OPERATION|OLD_VALUES|NEW_VALUES|TIMESTAMP|SCN|
        l_message := p_table_name || '|' ||
                    p_operation || '|'  ||
                    p_operation_key || '|' ||
                    p_operation_time_key || '|' ||
					p_pk1 || '|' ||
					NVL(p_pk2,'') || '|' ||
					NVL(p_pk3,'') || '|' ||
					NVL(p_pk4,'') || '|' ||
					NVL(p_pk5,'') || '|' ||
					NVL(p_pk6,'') || '|' ||
					NVL(p_pk7,'') || '|' ||
					NVL(p_pk8,'') || '|' ||
					NVL(p_pk9,'') || '|' ||
                    NVL(p_old_values, '') || '|' ||
                    NVL(p_new_values, '') || '|' ||
					NVL(p_valid_data, 'Y') || '|' ||
					NVL(p_processed_data, 'N') || '|' ||
					NVL(p_applied_data, 'N') || '|' ||
					TO_CHAR(p_changed_date, 'YYYY-MM-DD HH24:MI:SSxFF') || '|' ||
					p_changed_user;

--- Send this message too

	message := SYS.AQ$_JMS_TEXT_MESSAGE.CONSTRUCT;
	message.set_text(l_message);
	message_properties.priority := 0; 

-- Write to Queue
	l_success_flg := 'Y';

	DBMS_AQ.ENQUEUE(
		queue_name         => p_queue_name,
		enqueue_options    => enqueue_options,
		message_properties => message_properties,
		payload            => message,
		msgid              => message_handle
	);
	
	RETURN l_success_flg;

EXCEPTION
  WHEN OTHERS THEN
-- Standard Exception for queue failure
			
			l_errormsg := SUBSTR(SQLERRM, 1, 4000);
			l_success_flg := 'N';
			
			INSERT INTO SYNCUSER.CDC_ROW_AUDIT_1_AQ_ERROR_LOG(AUDITID, TABLENAME, 
														ERROR_MSG, CDC_AUDIT_MESSAGE_DATA,
														OPERATIONTYPE, OPERATIONKEY, OPERATIONTIMEKEY, 
														PK1, PK2, PK3, PK4, PK5, PK6, PK7, PK8, PK9, 
														BEFOREIMAGE, AFTERIMAGE, 
														VALID_DATA,PROCESSED_DATA, APPLIED_DATA,
														CHANGEDATE, CHANGEDBY) 
			VALUES(SYNCUSER.AUDITID_SEQ.NEXTVAL, p_table_name, 
					l_errormsg, l_message,
					p_operation, p_operation_key, p_operation_time_key, 
					p_pk1, p_pk2, p_pk3, p_pk4, p_pk5, p_pk6, p_pk7, p_pk8, p_pk9, 
					p_old_values, p_new_values, 
					p_valid_data, p_processed_data, p_applied_data,
					p_changed_date, p_changed_user);

        RETURN l_success_flg;
    END create_cdc_message;

END CDC_UTILS;
/


-- As SYS as SYSDBA do the following in the end
--- Give access to Application user - RMUSER 

GRANT SELECT, INSERT, UPDATE, DELETE ON SYNCUSER.CDC_ROW_AUDIT_1_AQ_ERROR_LOG TO RMUSER; --- Application user.
GRANT EXECUTE ON SYNCUSER.CDC_UTILS TO RMUSER;
GRANT SELECT ON SYNCUSER.AUDITID_SEQ TO RMUSER;

BEGIN
  DBMS_AQADM.GRANT_QUEUE_PRIVILEGE(
    privilege   => 'ALL',
    queue_name  => 'SYNCUSER.CDC_ROW_AUDIT_1_EVENT_QUEUE',
    grantee     => 'RMUSER',
    grant_option => FALSE
  );
END;
/

-- or use sysnonym and provide access to that

--- End of Pre Process 

---

-- Trigger with Logging on Failure
-- Run this as application user / Schema user
-- Code for every trigger process

CREATE OR REPLACE TRIGGER TRG_CUSTOMER_MASTER_CDC
    AFTER INSERT OR UPDATE OR DELETE ON SYNC_USER.Customer_master
    FOR EACH ROW
DECLARE


	l_queuename VARCHAR(100) := 'SYNCUSER.CDC_ROW_AUDIT_1_EVENT_QUEUE';
	l_tablename VARCHAR2(128) := 'Customer_master';
    l_operation VARCHAR2(1);
	l_operationkey Varchar2(32); -- Key based on table & Combining PKs 
	l_operationtimekey Varchar2(32);  -- Key based on table & Combining PKs & Datetime2

    l_pk1 varchar2(128);          -- 1st Primary key of the affected record
    l_pk2 varchar2(128) :='';          -- 2nd Primary key of the affected record
    l_pk3 varchar2(128) :='';          -- 3rd Primary key of the affected record
    l_pk4 varchar2(128) :='';          -- 4th Primary key of the affected record
    l_pk5 varchar2(128) :='';          -- 5th Primary key of the affected record
    l_pk6 varchar2(128) :='';          -- 6th Primary key of the affected record
    l_pk7 varchar2(128) :='';          -- 7th Primary key of the affected record
    l_pk8 varchar2(128) :='';          -- 8th Primary key of the affected record
    l_pk9 varchar2(128) :='';          -- 9th Primary key of the affected record

    l_old_values VARCHAR2(20000);
    l_new_values VARCHAR2(20000);

    l_valid Varchar2(1) := 'Y';
	l_processed Varchar2(1) := 'N';
	l_applied Varchar2(1) := 'N';
    l_timestamp TIMESTAMP := CURRENT_TIMESTAMP;
	l_user Varchar2(128) := USER;
	l_success_flg Varchar2(1) := 'Y';
    

BEGIN


    -- Determine operation type
    IF INSERTING THEN
        l_operation := 'I';
    ELSIF UPDATING THEN
        l_operation := 'U';
    ELSIF DELETING THEN
        l_operation := 'D';
    END IF;
    


--- All changes to happen in below section. Unique to trigger for a table.
	
    -- Format: column1:value1;column2:value2;...
		l_pk1 :='';          -- 1st Primary key of the affected record
		l_pk2 :='';          -- 2nd Primary key of the affected record
		l_pk3 :='';          -- 3rd Primary key of the affected record
		l_pk4 :='';          -- 4th Primary key of the affected record
		l_pk5 :='';          -- 5th Primary key of the affected record
		l_pk6 :='';          -- 6th Primary key of the affected record
		l_pk7 :='';          -- 7th Primary key of the affected record
		l_pk8 :='';          -- 8th Primary key of the affected record
		l_pk9 :='';          -- 9th Primary key of the affected record		
	
    IF UPDATING OR DELETING THEN

    -- Build old values string (for UPDATE and DELETE)

        l_old_values := '{Customer_id:' || SYNCUSER.CDC_UTILS.escape_string(TO_CHAR(:OLD.Customer_id)) || ';' ||
                       'Customer_name:' || SYNCUSER.CDC_UTILS.escape_string(:OLD.Customer_name) || ';' ||
                       'Customer_type:' || SYNCUSER.CDC_UTILS.escape_string(:OLD.Customer_type) || '}';
		l_pk1 := TO_CHAR(:OLD.Customer_id);
		l_operationkey := RAWTOHEX(DBMS_CRYPTO.HASH(UTL_I18N.STRING_TO_RAW(l_tablename || '|' || TO_CHAR(:OLD.Customer_id), 'AL32UTF8'),2)); -- As this version only supports MD5
		l_Operationtimekey := RAWTOHEX(DBMS_CRYPTO.HASH(UTL_I18N.STRING_TO_RAW(l_tablename || '|' || TO_CHAR(:OLD.Customer_id) || '|' || TO_CHAR(l_timestamp, 'YYYY-MM-DD HH24:MI:SSxFF'), 'AL32UTF8'),2)); -- As this version only supports MD5

		l_pk1 := TO_CHAR(:OLD.Customer_id);

    END IF;
    

    IF INSERTING OR UPDATING THEN

    -- Build new values string (for INSERT and UPDATE)

        l_new_values := '{Customer_id:' || SYNCUSER.CDC_UTILS.escape_string(TO_CHAR(:NEW.Customer_id)) || ';' ||
                       'Customer_name:' || SYNCUSER.CDC_UTILS.escape_string(:NEW.Customer_name) || ';' ||
                       'Customer_type:' || SYNCUSER.CDC_UTILS.escape_string(:NEW.Customer_type) || '}';

		l_OperationKey := RAWTOHEX(DBMS_CRYPTO.HASH(UTL_I18N.STRING_TO_RAW(l_tablename || '|' || TO_CHAR(:NEW.Customer_id), 'AL32UTF8'),2)); -- As this version only supports MD5

		l_OperationTimeKey := RAWTOHEX(DBMS_CRYPTO.HASH(UTL_I18N.STRING_TO_RAW(l_tablename || '|' || TO_CHAR(:NEW.Customer_id) || '|' || TO_CHAR(l_timestamp, 'YYYY-MM-DD HH24:MI:SSxFF'), 'AL32UTF8'),2)); -- As this version only supports MD5

		l_pk1 := TO_CHAR(:NEW.Customer_id);

----
-----------------------------------------------------------------------------------------------------------
-- Here we can check for Valid data validation - Create complete logic to check validity here --
-----------------------------------------------------------------------------------------------------------
    END IF;


----
---- Below is the common contruct for all CDC Data.


	l_success_flg := SYNCUSER.CDC_UTILS.create_cdc_message(
		p_queue_name => l_queuename,
        p_table_name => l_tablename,
        p_operation => l_operation,
		p_operation_key => l_operationkey,
		p_operation_time_key => l_operationtimekey,
		p_pk1 => l_pk1,
		p_pk2 => l_pk2,
		p_pk3 => l_pk3,
		p_pk4 => l_pk4,
		p_pk5 => l_pk5,
		p_pk6 => l_pk6,
		p_pk7 => l_pk7,
		p_pk8 => l_pk8,
		p_pk9 => l_pk9,
        p_old_values => l_old_values,
        p_new_values => l_new_values,
		p_valid_data => l_valid,
		p_processed_data => l_processed,
		p_applied_data => l_applied,
		p_changed_date => l_timestamp,
		p_changed_user => l_user
    );


	IF l_success_flg = 'N' THEN
		-- SMTP Message'
		NULL;
	END IF;


END;
/


